<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Basic Counter</title>
  <style>
    :root {
      --bg: #0b0c10;
      --card: #1f232b;
      --text: #e6edf3;
      --muted: #9aa4b2;
      --accent: #3ea6ff;
      --track: #2e3440;
      --ring: #3ea6ff;
      --danger: #ff6b6b;
      --ok: #22c55e;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: var(--bg); color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      display: grid; place-items: center;
    }
    .app { width: min(520px, 92vw); padding: 20px; background: var(--card); border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    .title { font-weight: 700; letter-spacing: .2px; margin: 0 0 16px; font-size: clamp(18px, 2.6vw, 22px); color: var(--text); }

    .ring-wrap { position: relative; width: 220px; height: 220px; margin: 8px auto 18px; }
    .count { position: absolute; inset: 0; display: grid; place-items: center; font-size: 48px; font-weight: 800; }

    .controls { display: grid; grid-template-columns: repeat(3,1fr); gap: 10px; margin: 12px 0 8px; }
    button {
      appearance: none; border: 0; padding: 12px 14px; border-radius: 12px; cursor: pointer;
      font-weight: 600; background: #2b313c; color: var(--text); transition: transform .04s ease, background .2s ease;
    }
    button:active { transform: translateY(1px); }
    .start { background: #213445; }
    .stop { background: #402b2b; }
    .reset { background: #2b3b2c; }

    .rows { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 6px; }
    .field { background: #2b313c; padding: 10px 12px; border-radius: 12px; }
    .field label { display:block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    .field input, .field select { width: 100%; padding: 10px 12px; border-radius: 8px; border: 1px solid #39414f; background: #222730; color: var(--text); font-size: 16px; }

    .note { text-align: center; margin-top: 10px; color: var(--muted); font-size: 12px; }

    .row-wide { display:flex; align-items:center; justify-content: space-between; gap:10px; margin-top:10px; color: var(--muted); }
    .row-wide input[type="checkbox"] { transform: scale(1.2); }
  </style>
</head>
<body>
  <main class="app" role="application" aria-label="Basic Counter">
    <h1 class="title">Basic Counter</h1>

    <div class="ring-wrap" aria-live="polite" aria-atomic="true">
      <svg width="220" height="220" viewBox="0 0 220 220" aria-hidden="true">
        <defs>
          <linearGradient id="g" x1="0" x2="1" y1="0" y2="1">
            <stop offset="0%" stop-color="var(--ring)"/>
            <stop offset="100%" stop-color="#7bd0ff"/>
          </linearGradient>
        </defs>
        <circle cx="110" cy="110" r="96" stroke="var(--track)" stroke-width="12" fill="none"></circle>
        <circle id="prog" cx="110" cy="110" r="96" stroke="url(#g)" stroke-width="12" fill="none"
                stroke-linecap="round" transform="rotate(-90 110 110)" stroke-dasharray="603.185" stroke-dashoffset="603.185"></circle>
      </svg>
      <div class="count"><span id="count">0</span></div>
    </div>

    <div class="controls">
      <button class="start" id="startBtn">Start</button>
      <button class="stop" id="stopBtn">Stop</button>
      <button class="reset" id="resetBtn">Reset</button>
    </div>

    <div class="rows">
      <div class="field">
        <label for="interval">Interval (seconds)</label>
        <select id="interval">
          <option>1</option><option>2</option><option>3</option><option>4</option><option>5</option>
          <option>6</option><option>7</option><option>8</option><option>9</option><option selected>10</option>
        </select>
      </div>
      <div class="field">
        <label for="limit">Limit (0 = no limit)</label>
        <select id="limit">
          <option value="0">0 (No limit)</option>
          <option>10</option><option>20</option><option>30</option><option>40</option><option>50</option>
          <option>60</option><option>70</option><option>80</option><option>90</option><option>100</option>
          <option>110</option><option>120</option>
        </select>
      </div>
    </div>

    <div class="row-wide">
      <label for="keepAwake">Keep screen awake (Android/Chrome only)</label>
      <input id="keepAwake" type="checkbox" />
    </div>
    <p class="note">Background counting is restricted by iOS/Android. This app now **catches up** missed ticks when you return. Enable "Keep screen awake" on supported browsers to avoid pausing.</p>
  </main>

  <script>
    // ------- State -------
    let running = false;
    let count = 0;
    let intervalSec = 1;
    let limit = 0;

    // Persisted timing to "catch up" after lock/background
    // We store the timestamp of the last tick (ms) and leftover remainder within the current interval
    let lastTickMs = null;     // Date.now() when we last processed a tick
    let remainderMs = 0;       // elapsed within current interval not yet forming a tick

    // Wake Lock support (Android Chrome). iOS Safari does not support this.
    let wakeLock = null;

    // Restore user settings
    try {
      const s = JSON.parse(localStorage.getItem('counter-settings') || '{}');
      if (s.intervalSec) intervalSec = Math.min(10, Math.max(1, s.intervalSec));
      if (typeof s.limit === 'number') limit = Math.max(0, s.limit);
      if (typeof s.count === 'number') count = Math.max(0, s.count);
      if (typeof s.remainderMs === 'number') remainderMs = Math.max(0, s.remainderMs);
      if (typeof s.lastTickMs === 'number') lastTickMs = s.lastTickMs;
      if (s.running) running = false; // always start paused for safety
    } catch {}

    // ------- Elements -------
    const $count = document.getElementById('count');
    const $prog = document.getElementById('prog');
    const $interval = document.getElementById('interval');
    const $limit = document.getElementById('limit');
    const $start = document.getElementById('startBtn');
    const $stop = document.getElementById('stopBtn');
    const $reset = document.getElementById('resetBtn');
    const $keepAwake = document.getElementById('keepAwake');

    const C = 2 * Math.PI * 96;
    $prog.setAttribute('stroke-dasharray', String(C));

    function drawProgress(frac){
      frac = Math.max(0, Math.min(1, frac));
      const offset = C * (1 - frac);
      $prog.setAttribute('stroke-dashoffset', String(offset));
    }

    function persist(){
      localStorage.setItem('counter-settings', JSON.stringify({
        intervalSec, limit, count, lastTickMs, remainderMs, running
      }));
    }

    function syncUI(){
      $count.textContent = String(count);
      $interval.value = String(intervalSec);
      $limit.value = String(limit);
      const frac = Math.min(1, remainderMs / (intervalSec * 1000));
      drawProgress(frac);
    }

    // ------- Core loop with catch-up -------
    let rafId = null;

    function loop(ts){
      if (!running) { rafId = null; return; }
      const now = Date.now();
      if (lastTickMs == null) lastTickMs = now;
      const ivMs = intervalSec * 1000;

      let delta = now - lastTickMs; // time since last accounted update
      if (delta < 0) delta = 0;

      // Add new time to remainder and compute how many whole ticks occurred
      remainderMs += delta;
      const ticks = Math.floor(remainderMs / ivMs);
      remainderMs = remainderMs % ivMs; // leftover for ring
      lastTickMs = now;

      if (ticks > 0){
        count += ticks;
        $count.textContent = String(count);
        if (limit > 0 && count >= limit){
          stop();
          alert(`Reached limit: ${limit}`);
          remainderMs = 0;
          drawProgress(0);
          persist();
          return;
        }
      }

      drawProgress(remainderMs / ivMs);
      rafId = requestAnimationFrame(loop);
    }

    function start(){
      if (running) return;
      if (limit > 0 && count >= limit){
        alert('Already at the limit. Reset or increase the limit.');
        return;
      }
      running = true;
      lastTickMs = Date.now();
      requestWakeLockIfNeeded();
      persist();
      rafId = requestAnimationFrame(loop);
    }

    function stop(){
      running = false;
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
      releaseWakeLock();
      persist();
    }

    function reset(){
      stop();
      count = 0;
      remainderMs = 0;
      lastTickMs = Date.now();
      drawProgress(0);
      $count.textContent = '0';
      persist();
    }

    $start.addEventListener('click', start);
    $stop.addEventListener('click', stop);
    $reset.addEventListener('click', reset);

    $interval.addEventListener('change', () => {
      intervalSec = Math.min(10, Math.max(1, parseInt($interval.value || '1', 10)));
      // Rebase remainder to the new interval proportionally
      remainderMs = Math.min(remainderMs, intervalSec * 1000);
      persist();
      // Keep timing continuous
      lastTickMs = Date.now();
    });

    $limit.addEventListener('change', () => {
      const v = parseInt($limit.value || '0', 10);
      limit = Math.max(0, isNaN(v) ? 0 : v);
      persist();
      if (limit > 0 && count >= limit) stop();
    });

    // Handle page visibility / background â†’ catch up using Date.now deltas
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible'){
        // Re-request wake lock if enabled
        if ($keepAwake.checked) requestWakeLockIfNeeded();
        // When returning, process any missed time in the next frame
        lastTickMs = Date.now();
      } else {
        // Browsers may suspend rAF; keep our timestamps so we can catch up later
        persist();
      }
    });

    // Wake Lock (Android Chrome)
    async function requestWakeLockIfNeeded(){
      if (!$keepAwake.checked) return;
      try {
        if ('wakeLock' in navigator){
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener('release', () => {});
        }
      } catch (e) { /* ignore */ }
    }
    function releaseWakeLock(){
      try{ if (wakeLock) { wakeLock.release(); wakeLock = null; } }catch(e){}
    }
    $keepAwake.addEventListener('change', () => {
      if ($keepAwake.checked && running) requestWakeLockIfNeeded();
      else releaseWakeLock();
      persist();
    });

    // Keyboard helpers (desktop): space toggles, 'r' resets
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); running ? stop() : start(); }
      if (e.key === 'r' || e.key === 'R') { e.preventDefault(); reset(); }
    });

    // Initial UI
    (function init(){
      $interval.value = String(intervalSec);
      $limit.value = String(limit);
      $count.textContent = String(count);
      drawProgress((remainderMs || 0) / (intervalSec * 1000));
    })();
  </script>
</body>
</html>
